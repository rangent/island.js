<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
		<title>Map</title>
        
        <link href="css/map.css" rel="stylesheet">

        <script type="text/javascript" src="js/rhill-voronoi-core.min.js"></script>
        <script type="text/javascript" src="js/paper.js"></script>
        <script type="text/javascript" src="js/Simplex.js"></script>
        <script type="text/javascript" src="js/perlin.js"></script>
        <script type="text/javascript" src="js/Island.js"></script>
	</head>

	<body style="font-family: monospace">
        <canvas id="land" height="500" width="500"></canvas>
        <canvas id="island"  height="500" width="500"></canvas>
        <canvas id="perlin" hidden="true"></canvas>
		
	<!-- BE NOTES:
	Island.diagram.cells is yummy
	getElevation() has command that controls elevation (more land vs. water)
	
	Set a breakpoint at paper.js @ 10490, on click:
	Island.diagram.cells[event.clientX + event.clientY * 200]; -> gives you the cell clicked
	-->
        
	<script type="application/javascript">
		//var Land = "";
		//var arr;
		var h = 100;
		var w = 100;
		var vidToArrCoords = {};
		
		/**
		 * @param {String} biome
		 * @param {Number} elevation
		 * @param {Number} moisture
		 * @param {Boolean} water
		 * @param {Boolean} ocean
		 * @param {Boolean} river
		 * @param {Integer} riverSize
		 * @param {Integer} x
		 * @param {Integer} y
		 */
		function loc(biome, elevation, moisture, water, ocean, river, riverSize, nextRiver, source, voronoiId, x, y) {
			this.biome = biome;
			this.elevation = elevation;
			this.moisture = moisture;
			this.water = water;
			this.ocean = ocean;
			this.river = river;
			this.riverSize = riverSize;
			this.nextRiver = nextRiver;
			this.source = source;
			this.voronoiId = voronoiId;
			this.x = x;
			this.y = y;
		}
		
		function generateLand(w, h) {
			var island = MakeIsland(Math.random());
			island.init({
				width: w, //BE: SHOULD BE SQRT(NBSITES) - 1
				height: h, //BE: SHOULD BE SQRT(NBSITES) - 1
				perlinWidth: 200,
				perlinHeight: 200,
				allowDebug: false, // if set to true, you can click on the map to enter "debug" mode. Warning : debug mode is slow to initialize, set to false for faster rendering.
				nbSites: 10000, // BE: SHOULD BE WIDTH * HEIGHT numbers of voronoi cell
				sitesDistribution: 'square', // distribution of the site of the voronoi graph : random, square or hexagon
				sitesRandomisation: 0, // BE: KEEP THIS 0, will move each site in a random way (in %), for the square or hexagon distribution to look more random
				nbGraphRelaxation: 0.0, // nb of time we apply the relaxation algo to the voronoi graph (slow !), for the random distribution to look less random
				cliffsThreshold: 0.1,
				lakesThreshold: 0.005, // lake elevation will increase by this value (* the river size) when a new river end inside
				nbRivers: (10000 / 200),
				maxRiversSize: 1,
				shading: 0.00,
				shadeOcean: true
			});
			return island;
		}
		
		function generateLandWithMountain(w, h) {
			var Land = generateLand(w, h);
			var num = 0;
			while (!landHasMountain(Land) && ++num < 10) {
				Land = generateLand(w, h);
			}
			//tag each of the cells with an ID
			for (var i = 0; i < Land.diagram.cells.length; i++) {
				Land.diagram.cells[i].vid = i;
			}
			return Land;
		}
		
		function findInitialStartingPoint(w, h, arr) {
			//find start point
			for (var i = h; i > 0; i--) {
				for (var j = 0; j < (h - i) && j < w; j++) {
					if (arr[i][j].biome != "OCEAN") {
						return [parseInt(j),parseInt(i)];
					}
				}				
			}
			return null;
		}
		
		function adjustStartPoint(strt, arr) {
			
			var check = [[1,0], [1,1], [0,1], [-1,1], [-1,0], [-1,-1], [0,-1], [1,-1]];
			
			//start on a hilltop
			var moved = false;
			for (var c in check) {
				var loc = arr[strt[1]+check[c][1]][strt[0]+check[c][0]];
				if (!moved && !loc.water && loc.biome != "BEACH") {
					loc.biome = "HILL";
					loc.water = false;
					strt = [strt[0]+check[c][0], strt[1]+check[c][1]];
					moved = true;
				}
			}
			
			//make sure theres at least one of the following biomes
			var requiredStartingBiomes = ["PLAINS", "FOREST"];
			check = [[1,0], [1,1], [0,1], [-1,1], [-1,0], [-1,-1], [0,-1], [1,-1],
					 [2,0], [2,1], [2,2], [1,2], [0,2], [-1,2], [-2,2], [-2,1], [-2,0],
					 [-2,-1], [-2,-2], [-1,-2], [0,-2], [1,-2], [2,-2], [2,-1]];
			for (var c in check) {
				var loc = arr[strt[1]+check[c][1]][strt[0]+check[c][0]];
				for (var b in requiredStartingBiomes) {
					if (loc.biome == requiredStartingBiomes[b]) {
						requiredStartingBiomes.splice(b,1);
					}
				}
			}
			//place any that we need
			for (var c in check) {
				if (requiredStartingBiomes.length > 0) {
					var loc = arr[strt[1]+check[c][1]][strt[0]+check[c][0]];
					if (!loc.water && loc.biome != "BEACH") {
						loc.biome = requiredStartingBiomes.pop();
						loc.water = false;
					}
				}
			}
			
			
			/*
			//MAKE ONE OF THE SURROUNDING LOCATIONS A HILL
			if (!arr[strt[1]+1][strt[0]].water && arr[strt[1]+1][strt[0]].biome != "BEACH") {
				//NEED TO DO THIS TO ALL OF THEM
			} else if (!arr[strt[1]+1][strt[0]+1].water && arr[strt[1]+1][strt[0]+1].biome != "BEACH") {
				arr[strt[1]+1][strt[0]+1].biome = "HILL";
				strt = [strt[0]+1, strt[1]+1];
			} else if (!arr[strt[1]][strt[0]+1].water && arr[strt[1]][strt[0]+1].biome != "BEACH") {
				arr[strt[1]][strt[0]+1].biome = "HILL";
				strt = [strt[0]+1, strt[1]];
			} else if (!arr[strt[1]-1][strt[0]+1].water && arr[strt[1]-1][strt[0]+1].biome != "BEACH") {
				arr[strt[1]-1][strt[0]+1].biome = "HILL";
				strt = [strt[0]+1, strt[1]-1];
			} else if (!arr[strt[1]-1][strt[0]].water && arr[strt[1]-1][strt[0]].biome != "BEACH") {
				arr[strt[1]-1][strt[0]].biome = "HILL";
				strt = [strt[0], strt[1]-1];
			} else if (!arr[strt[1]-1][strt[0]-1].water && arr[strt[1]-1][strt[0]-1].biome != "BEACH") {
				arr[strt[1]-1][strt[0]-1].biome = "HILL";
				strt = [strt[0]-1, strt[1]-1];
			} else if (!arr[strt[1]][strt[0]-1].water && arr[strt[1]][strt[0]-1].biome != "BEACH") {
				arr[strt[1]][strt[0]-1].biome = "HILL";
				strt = [strt[0]-1, strt[1]];
			} else {
				arr[strt[1]+1][strt[0]-1].biome = "HILL";
				strt = [strt[0]-1, strt[1]+1];
			}
			*/
			return strt;
		}
		
		function getBiomeColor(biome) {
			switch(biome) {
				case "OCEAN": return '#82caff';
				case "BEACH": return '#ffe98d';
				case "LAKE": return '#2f9ceb';
				case "MOUNTAIN": return '#535353';
				case "FOREST": return '#a9cca4';
				case "HILL": return '#a49486';
				case "PLAINS": return '#c9dca4';
				default: return '#ffffff';
			}
		}
		
		function landHasMountain(Land) {
			var numMtn = 0
			for (var i = 0; i < Land.diagram.cells.length; i++) {
				if (typeof Land.diagram.cells[i].biome === "undefined") {
					debugger;
				}
				if (Land.diagram.cells[i].biome == "MOUNTAIN") {
					if (++numMtn >= 10) {
						return true;
					}
				}
			}
			return false;
		}
		
		function cloneIsland(Land, w, h) {
			var arr = new Array(h);
			for (var y = 0; y < h; y++) {
				arr[y] = new Array(w);
				for (var x = 0; x < w; x++) {
					//find the closest one:
					var closestIndex = 0;
					var closestDistance = 100000000;
					var pt = new Point(x, y);
					//extremely inefficient... but it only gets run on setup... so whatever :-/
					for (var i = 0; i < Land.diagram.cells.length; i++) {
						var pt2 = new Point(Land.diagram.cells[i].site.x, Land.diagram.cells[i].site.y);
						var d = distance(pt, pt2);
						if (d < closestDistance) {
							closestIndex = i;
							closestDistance = d;
						}
					}
					vidToArrCoords[closestIndex] = x + "," + y;
					var cell = Land.diagram.cells[closestIndex];
					if (typeof cell === "undefined") {
						debugger;
					}
					var river = (typeof cell.river === "undefined") ? false : cell.river;
					var riverSize = (typeof cell.riverSize === "undefined") ? 0 : cell.riverSize;
					if (typeof cell.biome === "undefined") {
						debugger;
					}
					arr[y][x] = new loc(cell.biome, cell.elevation, cell.moisture, cell.water, cell.ocean, river, riverSize, cell.nextRiver, cell.source, cell.site.voronoiId, x, y);
				}
			}
			return arr;
		}
		
		function drawAndAlignMap(arr, strt) {
			
			var a = new Array(10000);
			for (var i = 0; i < 10000; i++) {
				a[i] = 0;
			}
			
			var cnvs=document.getElementById("land");
			var ctx=cnvs.getContext("2d");
			
			for (var y = 0; y < h; y++) {
				for (var x = 0; x < w; x++) {
					a[arr[y][x].voronoiId]++;
					ctx.fillStyle = getBiomeColor(arr[y][x].biome);
					ctx.fillRect(x * 5, y * 5, 5, 5);
					if ((arr[y][x].river || arr[y][x].nextRiver) && arr[y][x].biome != "OCEAN" && arr[y][x].biome != "LAKE" ) {
						//debugger;
						if (typeof vidToArrCoords[arr[y][x].nextRiver.vid] !== "undefined") {
							var coords = vidToArrCoords[arr[y][x].nextRiver.vid].split(",");
							if (arr[coords[1]][coords[0]].biome != "OCEAN") {
								ctx.beginPath();
								ctx.moveTo(x * 5 - 2.5, y * 5 - 2.5);
								ctx.lineTo(coords[0] * 5 - 2.5, coords[1] * 5 - 2.5);
								ctx.lineWidth = (typeof arr[y][x].riverSize === "undefined") ? 2 : arr[y][x].riverSize * 3.5;
								ctx.strokeStyle = "#2f9ceb";
								ctx.stroke();
							}
						}
						else {
							var xctr = x * 5 + 2.5;
							var yctr = y * 5 + 2.5;
							ctx.beginPath();
							ctx.arc(xctr, yctr, 2.5, 0, 2 * Math.PI, false);
							ctx.fillStyle = "#2f9ceb";
							ctx.fill();
							ctx.closePath();
						}
					}
				}
			}
			
			ctx.fillStyle="red";
			ctx.fillRect(strt[0] * 5, strt[1] * 5, 5, 5);
			
			//find the ones that aren't mapped to anything
			for (var i = 0; i < 10000; i++) {
				if (a[i]==0) {
					vidToArrCoords[i] = Land.diagram.cells[i].site.x + "," + Land.diagram.cells[i].site.y;
				}
			}
		}
		
		function distance(a, b) {
            var dx = a.x - b.x,
                dy = a.y - b.y;
            return Math.sqrt(dx * dx + dy * dy);
        }
		
		paper.install(window);
		window.onload = function(e) {
			paper.setup('island');
			
			Land = generateLandWithMountain(w,h);
			
			//make the array
			var arr = cloneIsland(Land, w, h);
			
			var strt = findInitialStartingPoint(w, h, arr);
			strt = adjustStartPoint(strt, arr);
			
			drawAndAlignMap(arr, strt);			
		};
	</script>
    <noscript>You need to enable Javascript in your browser for this page to display properly.</noscript>
	</body>
</html>