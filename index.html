<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
		<title>Map</title>
        
        <link href="css/map.css" rel="stylesheet">

        <script type="text/javascript" src="js/rhill-voronoi-core.min.js"></script>
        <script type="text/javascript" src="js/paper.js"></script>
        <script type="text/javascript" src="js/Simplex.js"></script>
        <script type="text/javascript" src="js/perlin.js"></script>
        <script type="text/javascript" src="js/Island.js"></script>
	</head>

	<body style="font-family: monospace">
        <canvas id="land" height="500" width="500"></canvas>
        <canvas id="island"  height="500" width="500"></canvas>
        <canvas id="perlin" hidden="true"></canvas>
		
	<!-- BE NOTES:
	Island.diagram.cells is yummy
	getElevation() has command that controls elevation (more land vs. water)
	
	Set a breakpoint at paper.js @ 10490, on click:
	Island.diagram.cells[event.clientX + event.clientY * 200]; -> gives you the cell clicked
	-->
        
	<script type="application/javascript">
		var Land = "";
		var arr;
		var h = 100;
		var w = 100;
		var vidToArrCoords = {};
		var tbl = "<table style='font-size:6pt; font-family:monospace' cellpadding='0' cellspacing='0'>";
		
		
		/**
		 * @param {String} biome
		 * @param {Number} elevation
		 * @param {Number} moisture
		 * @param {Boolean} water
		 * @param {Boolean} ocean
		 * @param {Boolean} river
		 * @param {Integer} riverSize
		 * @param {Integer} x
		 * @param {Integer} y
		 */
		function loc(biome, elevation, moisture, water, ocean, river, riverSize, nextRiver, source, voronoiId, x, y) {
			this.biome = biome;
			this.elevation = elevation;
			this.moisture = moisture;
			this.water = water;
			this.ocean = ocean;
			this.river = river;
			this.riverSize = riverSize;
			this.nextRiver = nextRiver;
			this.source = source;
			this.voronoiId = voronoiId;
			this.x = x;
			this.y = y;
		}
		
		function generateLand(w, h) {
			var island = MakeIsland(Math.random());
			island.init({
				width: w, //BE: SHOULD BE SQRT(NBSITES) - 1
				height: h, //BE: SHOULD BE SQRT(NBSITES) - 1
				perlinWidth: 200,
				perlinHeight: 200,
				allowDebug: false, // if set to true, you can click on the map to enter "debug" mode. Warning : debug mode is slow to initialize, set to false for faster rendering.
				nbSites: 10000, // BE: SHOULD BE WIDTH * HEIGHT numbers of voronoi cell
				sitesDistribution: 'square', // distribution of the site of the voronoi graph : random, square or hexagon
				sitesRandomisation: 0, // BE: KEEP THIS 0, will move each site in a random way (in %), for the square or hexagon distribution to look more random
				nbGraphRelaxation: 0.0, // nb of time we apply the relaxation algo to the voronoi graph (slow !), for the random distribution to look less random
				cliffsThreshold: 0.1,
				lakesThreshold: 0.005, // lake elevation will increase by this value (* the river size) when a new river end inside
				nbRivers: (10000 / 200),
				maxRiversSize: 1,
				shading: 0.00,
				shadeOcean: true
			});
			return island;
		}
		
		function findStart(w, h, arr) {
			//find start point
			for (var i = h; i > 0; i--) {
				for (var j = 0; j < (h - i) && j < w; j++) {
					if (arr[i][j].biome != "OCEAN") {
						//Island.diagram.cells[j,i]
						console.log("startat: " + j + ", " + i);
						return j + "," + i;
					}
				}				
			}
			return null;
		}
		
		function getBiomeColor(biome) {
			switch(biome) {
				case "OCEAN": return '#82caff';
				case "BEACH": return '#ffe98d';
				case "LAKE": return '#2f9ceb';
				case "MOUNTAIN": return '#535353';
				case "FOREST": return '#a9cca4';
				case "HILL": return '#a49486';
				case "PLAINS": return '#c9dca4';
				default: return '#ffffff';
			}
		}
		
		function islandHasMountain() {
			var numMtn = 0
			for (var i = 0; i < Land.diagram.cells.length; i++) {
				if (typeof Land.diagram.cells[i].biome === "undefined") {
					debugger;
				}
				if (Land.diagram.cells[i].biome == "MOUNTAIN") {
					if (++numMtn >= 10) {
						return true;
					}
				}
			}
			return false;
		}
		
		function distance(a, b) {
            var dx = a.x - b.x,
                dy = a.y - b.y;
            return Math.sqrt(dx * dx + dy * dy);
        }
		
		paper.install(window);
		window.onload = function(e) {
			paper.setup('island');

			var islandCanvas = document.getElementById('island');
			var perlinCanvas = document.getElementById('perlin');
			

			//islandCanvas.onclick = function() {
			//    Island.toggleDebug();
			//    perlinCanvas.style.display = (perlinCanvas.style.display == 'block' ? 'none' : 'block');
			//};
			
			//Island.init();
			Land = generateLand(w, h);
			var num = 0;
			while (!islandHasMountain() && ++num < 10) {
				Land = generateLand(w, h);
			}
			
			for (var i = 0; i < Land.diagram.cells.length; i++) {
				Land.diagram.cells[i].vid = i;
			}
			
			//make the array
			//debugger;
			arr = new Array(h);
			for (var y = 0; y < h; y++) {
				arr[y] = new Array(w);
				for (var x = 0; x < w; x++) {
					//find the closest one:
					var closestIndex = 0;
					var closestDistance = 100000000;
					var pt = new Point(x, y);
					for (var i = 0; i < Land.diagram.cells.length; i++) {
						var pt2 = new Point(Land.diagram.cells[i].site.x, Land.diagram.cells[i].site.y);
						var d = distance(pt, pt2);
						if (d < closestDistance) {
							closestIndex = i;
							closestDistance = d;
						}
					}
					vidToArrCoords[closestIndex] = x + "," + y;
					//var cell = Land.diagram.cells[x + y * h];
					var cell = Land.diagram.cells[closestIndex];
					if (typeof cell === "undefined") {
						debugger;
					}
					var river = (typeof cell.river === "undefined") ? false : cell.river;
					var riverSize = (typeof cell.riverSize === "undefined") ? 0 : cell.riverSize;
					if (typeof cell.biome === "undefined") {
						debugger;
					}
					//loc(biome, elevation, moisture, water, ocean, river, riverSize, nextRiver, source, voronoiId, x, y)
					arr[y][x] = new loc(cell.biome, cell.elevation, cell.moisture, cell.water, cell.ocean, river, riverSize, cell.nextRiver, cell.source, cell.site.voronoiId, x, y);
				}
			}
			/*
			for (var y = 1; y < h-1; y++) {
				tbl += "<tr>";
				for (var x = 0; x < w; x++) {
					if (arr[y][x].biome=="MOUNTAIN") { tbl += "<td width='9px' bgcolor='#535353' "; }
					if (arr[y][x].biome=="FOREST") { tbl += "<td width='9px' bgcolor='#a9cca4' "; }
					if (arr[y][x].biome=="HILL") { tbl += "<td width='9px' bgcolor='#a49486' "; }
					if (arr[y][x].biome=="PLAINS") { tbl += "<td width='9px' bgcolor='#c9dca4' "; }
					if (arr[y][x].biome=="OCEAN") { tbl += "<td width='9px' bgcolor='#82caff' "; }
					if (arr[y][x].biome=="BEACH") { tbl += "<td width='9px' bgcolor='#ffe98d' "; }
					if (arr[y][x].biome=="LAKE") { tbl += "<td width='9px' bgcolor='#2f9ceb' "; }
					if (typeof arr[y][x].river !== "undefined" && arr[y][x].river) {
						//debugger;
						tbl += "style=\"border: 1px solid blue\" ";
					}
					tbl += ">" + arr[y][x].biome.substr(0,1)+"</td>";
				}
				tbl += "</tr>";
			}
			tbl += "</table>";
			document.write(tbl); //draw the map in an HTML table
			*/
			
			var cnvs=document.getElementById("land");
			var ctx=cnvs.getContext("2d");
			
			var a = new Array(10000);
			for (var i = 0; i < 10000; i++) {
				a[i] = 0;
			}
			
			for (var y = 0; y < h; y++) {
				for (var x = 0; x < w; x++) {
					a[arr[y][x].voronoiId]++;
					ctx.fillStyle = getBiomeColor(arr[y][x].biome);
					ctx.fillRect(x * 5, y * 5, 5, 5);
					/*
					if (arr[y][x].source) {
						var xctr = x * 5 + 2.5;
						var yctr = y * 5 + 2.5;
						ctx.beginPath();
						ctx.arc(xctr, yctr, 2.5, 0, 2 * Math.PI, false);
						ctx.fillStyle = "#0000ee";
						ctx.fill();
						ctx.closePath();
					}
					*/
					if ((arr[y][x].river || arr[y][x].nextRiver) && arr[y][x].biome != "OCEAN" && arr[y][x].biome != "LAKE" ) {
						//debugger;
						var coords = vidToArrCoords[arr[y][x].nextRiver.vid].split(",");
						if (arr[coords[1]][coords[0]].biome != "OCEAN") {
							ctx.beginPath();
							ctx.moveTo(x * 5 - 2.5, y * 5 - 2.5);
							ctx.lineTo(coords[0] * 5 - 2.5, coords[1] * 5 - 2.5);
							ctx.lineWidth = (typeof arr[y][x].riverSize === "undefined") ? 2 : arr[y][x].riverSize * 3.5;
							ctx.strokeStyle = "#2f9ceb";
							ctx.stroke();
						}
					}
				}
			}
			
			var strt = findStart(w, h, arr).split(",");
			ctx.fillStyle="red";
			ctx.fillRect(strt[0] * 5, strt[1] * 5, 5, 5);
			
			//find the ones that aren't mapped to anything
			for (var i = 0; i < 10000; i++) {
				if (a[i]==0) {
					console.log(i);
					vidToArrCoords[i] = Land.diagram.cells[i].site.x + "," + Land.diagram.cells[i].site.y;
				}
			}
			
			
			
		};
	</script>
    <noscript>You need to enable Javascript in your browser for this page to display properly.</noscript>
	</body>
</html>